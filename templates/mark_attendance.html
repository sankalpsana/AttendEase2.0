{% extends "base.html" %}

{% block title %}Mark Attendance - AttendEase{% endblock %}

{% block header %}Mark Attendance - {{ section_name }}{% endblock %}

{% block content %}
<div class="row g-4">
    <!-- Webcam Feed -->
    <div class="col-lg-8">
        <div class="content-card text-center">
            <h5 class="mb-3 text-primary"><i class="fas fa-video me-2"></i>Live Video Feed</h5>

            <div class="position-relative d-inline-block rounded overflow-hidden shadow-sm" style="max-width: 100%;">
                <video id="video" autoplay playsinline
                    style="width: 100%; max-width: 640px; border-radius: 10px;"></video>
                <canvas id="canvas"
                    style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></canvas>
            </div>

            <div class="mt-2 text-center">
                <p id="cameraStatus" class="text-muted small">Initializing camera...</p>
            </div>
            <div class="mt-3 d-flex justify-content-center">
                <select id="cameraSelect" class="form-select w-auto" style="min-width: 200px;">
                    <option value="">Select Camera</option>
                </select>
            </div>
        </div>
    </div>

    <!-- Attendance Grid -->
    <div class="col-lg-4">
        <div class="content-card h-100">
            <h5 class="mb-3 text-success"><i class="fas fa-th me-2"></i>Student Status</h5>

            <div class="attendance-grid custom-scrollbar" style="max-height: 400px; overflow-y: auto;">
                {% for student in students %}
                <div class="attendance-box shadow-sm" data-student-id="{{ student.roll_number }}"
                    title="{{ student.name }}">
                    <span class="fw-bold">{{ student.roll_number }}</span>
                </div>
                {% endfor %}
            </div>

            <div class="mt-4 pt-3 border-top">
                <button id="stopButton" class="btn btn-gradient w-100 py-2">
                    <i class="fas fa-check-circle me-2"></i>Submit Attendance
                </button>
            </div>
        </div>
    </div>
</div>

<style>
    .attendance-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
        gap: 10px;
        padding: 5px;
    }

    .attendance-box {
        background-color: #ff6b6b;
        /* Red for absent */
        color: white;
        padding: 10px 5px;
        text-align: center;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        font-size: 0.9rem;
        user-select: none;
    }

    .attendance-box:hover {
        transform: scale(1.05);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
    }

    .attendance-box.present {
        background-color: #38ef7d;
        /* Green for present */
        transform: translateY(-2px);
    }

    .custom-scrollbar::-webkit-scrollbar {
        width: 6px;
    }

    .custom-scrollbar::-webkit-scrollbar-track {
        background: #f1f1f1;
    }

    .custom-scrollbar::-webkit-scrollbar-thumb {
        background: #ccc;
        border-radius: 3px;
    }
</style>
{% endblock %}

{% block scripts %}
<script>
    // Access the webcam
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const cameraSelect = document.getElementById('cameraSelect');
    const cameraStatus = document.getElementById('cameraStatus');
    let stream;
    let detectedStudents = new Set();

    // Config variables
    const FACULTY_ID = '{{ faculty_id }}';
    const SUBJECT_ID = '{{ subject_id }}';
    const SECTION_NAME = '{{ section_name }}';

    function updateStatus(msg, type = 'text-muted') {
        cameraStatus.textContent = msg;
        cameraStatus.className = `small ${type}`;
    }

    async function getCameras() {
        updateStatus("Requesting camera permissions...");
        try {
            const initialStream = await navigator.mediaDevices.getUserMedia({ video: true });
            updateStatus("Permission granted. Enumerating devices...");

            initialStream.getTracks().forEach(track => track.stop());

            const devices = await navigator.mediaDevices.enumerateDevices();
            const videoDevices = devices.filter(device => device.kind === 'videoinput');

            cameraSelect.innerHTML = '<option value="">Select Camera</option>';
            videoDevices.forEach((device, index) => {
                const label = device.label || `Camera ${index + 1}`;
                cameraSelect.innerHTML += `<option value="${device.deviceId}">${label}</option>`;
            });
            if (videoDevices.length === 0) {
                updateStatus("No video devices found.", "text-danger");
            }
        } catch (err) {
            console.error("Error enumerating cameras:", err);
            updateStatus("Error: " + err.message, "text-danger");
        }
    }

    async function startCamera(deviceId) {
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
        }

        updateStatus("Starting camera stream...");

        // Try simple constraints first if no device ID
        let constraints = { video: true };

        if (deviceId) {
            constraints = {
                video: {
                    deviceId: { exact: deviceId },
                    width: { ideal: 640 },
                    height: { ideal: 480 }
                }
            };
        } else {
            // If no deviceId, prefer ideal resolution but keep it optional
            constraints = {
                video: {
                    width: { ideal: 640 },
                    height: { ideal: 480 }
                }
            };
        }

        try {
            stream = await navigator.mediaDevices.getUserMedia(constraints);
            video.srcObject = stream;
            // Explicitly play to avoid autoplay policy issues
            try {
                await video.play();
                updateStatus("Camera active.", "text-success fw-bold");
            } catch (playErr) {
                console.error("Autoplay failed:", playErr);
                updateStatus("Click to enable video (Autoplay blocked).", "text-warning");
                // Add click listener to video to play
                video.addEventListener('click', () => video.play());
            }

        } catch (err) {
            console.error("Error accessing camera with constraints:", err);
            updateStatus("Retrying with simple constraints...", "text-warning");

            // Fallback to simple video request
            try {
                stream = await navigator.mediaDevices.getUserMedia({ video: true });
                video.srcObject = stream;
                await video.play();
                updateStatus("Camera active (Fallback).", "text-success fw-bold");
            } catch (fallbackErr) {
                console.error("Fallback camera access failed:", fallbackErr);
                updateStatus("Camera Fail: " + fallbackErr.message, "text-danger fw-bold");
                alert("Could not access camera. Error: " + fallbackErr.message);
            }
        }
    }

    // Initialize
    async function initCamera() {
        await getCameras();
        // Allow time for UI update
        setTimeout(() => startCamera(), 500);
    }

    initCamera();

    cameraSelect.addEventListener('change', () => {
        startCamera(cameraSelect.value);
    });

    // Mark student present UI
    function markStudentPresent(studentId) {
        const box = document.querySelector(`.attendance-box[data-student-id="${studentId}"]`);
        if (box && !box.classList.contains('present')) {
            box.classList.add('present');
            // Optional: Scroll grid to show the newly marked student? 
            // box.scrollIntoView({behavior: 'smooth', block: 'nearest'});
        }
    }

    // Manual toggle
    document.querySelector('.attendance-grid').addEventListener('click', (e) => {
        const box = e.target.closest('.attendance-box');
        if (box) {
            box.classList.toggle('present');
        }
    });

    // Submit Attendance
    document.getElementById('stopButton').addEventListener('click', () => {
        const presentStudents = [];
        const allStudents = [];

        document.querySelectorAll('.attendance-box').forEach(box => {
            const id = box.getAttribute('data-student-id');
            allStudents.push(id);
            if (box.classList.contains('present')) {
                presentStudents.push(id);
            }
        });

        const absentStudents = allStudents.filter(id => !presentStudents.includes(id));

        // Disable button during submit
        const btn = document.getElementById('stopButton');
        const originalText = btn.innerHTML;
        btn.disabled = true;
        btn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Submitting...';

        fetch('/submit-attendance', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                faculty_id: FACULTY_ID,
                subject_id: SUBJECT_ID,
                section_name: SECTION_NAME,
                present_students: presentStudents,
                absent_students: absentStudents,
            }),
        })
            .then(res => res.json())
            .then(data => {
                if (data.success) {
                    alert("Attendance submitted successfully!");
                    window.location.href = '/dashboard';
                } else {
                    alert("Error: " + data.message);
                    btn.disabled = false;
                    btn.innerHTML = originalText;
                }
            })
            .catch(err => {
                console.error(err);
                alert("Submission failed.");
                btn.disabled = false;
                btn.innerHTML = originalText;
            });
    });

    // Socket.IO Logic
    // const socket = io(); // Already declared in base.html
    // We use the global 'socket' variable.

    socket.on('connect', () => {
        console.log('Connected to WebSocket');
    });

    socket.on('frame_processed', (data) => {
        if (video.videoWidth && (canvas.width !== video.videoWidth || canvas.height !== video.videoHeight)) {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
        }

        const scaleX = canvas.width / (data.processed_width || canvas.width);
        const scaleY = canvas.height / (data.processed_height || canvas.height);

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (data.success && data.faces) {
            data.faces.forEach(face => {
                const { student_id, location } = face;
                let [top, right, bottom, left] = location;

                // Scale coordinates back to original video size
                if (data.processed_width) {
                    top *= scaleY;
                    bottom *= scaleY;
                    left *= scaleX;
                    right *= scaleX;
                }

                // Scale coordinates if displayed video size implies scaling (CSS vs Intrinsic)
                // Since canvas overlays video 1:1 intrinsic resolution-wise (set in logic above), 
                // but displayed via CSS width:100% inside container.
                // The canvas is positioned absolute with width/height 100%. 
                // We must ensure the drawing matches the visual scale if needed.
                // Actually, if we set canvas.width = video.videoWidth, the CSS scaling applies to both equally.

                ctx.strokeStyle = '#38ef7d';
                ctx.lineWidth = 3;
                ctx.strokeRect(left, top, right - left, bottom - top);

                ctx.font = 'bold 16px "Segoe UI"';
                const text = student_id;
                const textWidth = ctx.measureText(text).width;

                ctx.fillStyle = '#38ef7d';
                ctx.fillRect(left, top - 25, textWidth + 10, 25);

                ctx.fillStyle = '#000';
                ctx.fillText(text, left + 5, top - 7);

                if (student_id !== "Unknown") {
                    markStudentPresent(student_id);
                }
            });
        }

        // Acknowledge processing complete
        isProcessing = false;
    });

    let isProcessing = false;

    function sendFrame() {
        if (!video.videoWidth || !socket.connected || isProcessing) return;

        isProcessing = true;

        // Auto-reset if stuck (e.g. server timeout)
        setTimeout(() => { isProcessing = false; }, 5000);

        const frameCanvas = document.createElement('canvas');
        // Resize to 500px width (balance between speed and accuracy)
        const scale = Math.min(1, 500 / video.videoWidth);
        const processingWidth = video.videoWidth * scale;
        const processingHeight = video.videoHeight * scale;

        frameCanvas.width = processingWidth;
        frameCanvas.height = processingHeight;

        const frameCtx = frameCanvas.getContext('2d');
        frameCtx.drawImage(video, 0, 0, processingWidth, processingHeight);

        const imageData = frameCanvas.toDataURL('image/jpeg', 0.6); // Lower quality to 0.6

        socket.emit('process_frame', {
            image: imageData,
            section_name: SECTION_NAME,
            width: processingWidth,
            height: processingHeight
        });
    }

    // Check every 500ms if we can send a frame
    setInterval(sendFrame, 500);

</script>
{% endblock %}